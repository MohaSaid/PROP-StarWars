import java.util.LinkedList;
import java.util.Queue;


public class PR{

	private Grafo g;
	private int flujo[][];
	private int residual[][];
	private int peso[];
	private int exceso[];
	
	public void GrafoPR(Grafo f) {
		g = f;
	}
	
	private void Inicializar(int s, int t) {
		int n = g.sizeGrafo();
		peso = new int[n];
		peso[s] = n;
		exceso = new int[n];
		flujo = new int[n][n];
		residual = new int[n][n];
		int v = 0;
		int aux;
		for(int i = 0; i < g.sizeGrafo(s); ++i) {
			v = g.consultaPair(s, i).consultarSegundo();
			aux = g.consultaPair(s, i).consultarPrimero().ConsultarCapacidad();
			flujo[s][v] = aux;
			flujo[v][s] = - aux;
			exceso[v] = aux;
			exceso[s] -= aux;
			residual[s][v] = aux - flujo[s][v];
			if(g.existeV(v, s)) aux = g.consultaPair(v, s).consultarPrimero().ConsultarCapacidad();
			else aux = 0; 
			residual[v][s] = aux - flujo[v][s];
		}
	}
	private void push(int u, int v) {
		int temp = Math.min(exceso[u], residual[u][v]);
		flujo[u][v] = flujo[u][v] + temp;
		flujo[v][u] = - flujo[u][v];
		exceso[u] = exceso[u] - temp;
		exceso[v] = exceso[v] + temp;
		residual[u][v] = g.consultaPairUn(u, v).consultarPrimero().ConsultarCapacidad() - flujo[u][v];
		if(g.existeV(v, u)) temp =g.consultaPairUn(v, u).consultarPrimero().ConsultarCapacidad();
		else temp = 0;
		residual[v][u] = temp - flujo[v][u];
	}
	
	public int consultarMF(int t) {
		 return exceso[t];
	}
	
	public int[][] grafoResidual() {
		return residual;
	}
	public void maxflowfifo(int f, int s){
		Inicializar(f, s);
		Queue<Integer> q = new LinkedList<Integer>();
		boolean visitados[] = new boolean[g.sizeGrafo()];
		int u, v, temp;
		for(int i = 0; i < g.sizeGrafo(f); ++i) {
			v = g.consultaPair(f, i).consultarSegundo();
			if(v != s) {
				q.add(v);
				visitados[v] = true;
			}
		}
		while (q.size() != 0) {
			u = q.peek();
			//sSystem.out.println("SIZE " + q.size());
			temp = -1;
			for (int i = 0; i < g.sizeGrafo(u) && exceso[u] > 0; ++i) {
				
				v = g.consultaPair(u, i).consultarSegundo();
				if(residual[u][v] > 0) {
					if(peso[u] > peso[v]) {
						push(u,v);
						if(!visitados[v] && v != f && v != s) {
							visitados[v] = true;
							q.add(v);
						}
					}
					else if(temp == -1) temp = peso[v];
					else temp = Math.min(temp,peso[v]);
				}
			}
			if(exceso[u] != 0) peso[u] = 1 + temp;
			else {
				System.out.println("while");
				visitados[u] = false;
				q.poll();
			}
		}
	}
}
